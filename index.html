<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Live Markdown Search</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" />
    <style>
      :root {
        color-scheme: light dark;
        font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background-color: #f3f4f6;
        color: #111827;
      }

      body {
        margin: 0;
        padding: 2rem;
        background: var(--body-bg, #f3f4f6);
      }

      h1 {
        text-align: center;
        margin-bottom: 1.5rem;
      }

      .app-grid {
        display: grid;
        gap: 1.5rem;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        margin-bottom: 2rem;
      }

      .card {
        background: #ffffff;
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 15px 35px rgba(15, 23, 42, 0.08);
      }

      .card h2 {
        margin-top: 0;
        font-size: 1.1rem;
        margin-bottom: 0.75rem;
      }

      label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 600;
      }

      input[type='text'],
      select,
      button,
      table {
        width: 100%;
      }

      input[type='text'],
      select {
        padding: 0.6rem;
        border-radius: 8px;
        border: 1px solid #d1d5db;
        font-size: 1rem;
      }

      button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.35rem;
        padding: 0.65rem 0.75rem;
        border: none;
        border-radius: 8px;
        background: #2563eb;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }

      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 20px rgba(37, 99, 235, 0.2);
      }

      button:disabled {
        background: #9ca3af;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }

      .inline-actions {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .results {
        display: grid;
        gap: 1rem;
      }

      .result-card {
        background: #ffffff;
        border-radius: 12px;
        padding: 1rem 1.25rem;
        box-shadow: 0 10px 25px rgba(15, 23, 42, 0.1);
      }

      .result-card h3 {
        margin-top: 0;
        margin-bottom: 0.75rem;
        font-size: 1.05rem;
      }

      .match-line {
        margin: 0.4rem 0;
        padding: 0.5rem;
        border-radius: 6px;
        background: #f9fafb;
        border-left: 3px solid #2563eb;
        font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        white-space: pre-wrap;
      }

      mark {
        background: #f59e0b;
        color: inherit;
        padding: 0 0.15rem;
        border-radius: 4px;
      }

      table {
        border-collapse: collapse;
        margin-top: 0.75rem;
      }

      th,
      td {
        padding: 0.6rem;
        text-align: left;
        border-bottom: 1px solid #e5e7eb;
        font-size: 0.95rem;
      }

      th {
        cursor: pointer;
      }

      .status {
        margin-bottom: 1rem;
        padding: 0.75rem 1rem;
        border-radius: 10px;
        background: #eef2ff;
        color: #1e3a8a;
        display: none;
      }

      .hidden-input {
        display: none;
      }

      footer {
        margin-top: 3rem;
        text-align: center;
        font-size: 0.85rem;
        color: #6b7280;
      }

      @media (max-width: 640px) {
        body {
          padding: 1rem;
        }

        .card {
          padding: 1.25rem;
        }
      }
    </style>
  </head>
  <body>
    <h1>üìÑ Live Markdown Search</h1>

    <div id="status" class="status"></div>

    <section class="app-grid">
      <article class="card" id="login-card">
        <h2>Login</h2>
        <label for="username">Username</label>
        <input id="username" type="text" placeholder="e.g. Alice" />

        <label for="role">Role</label>
        <select id="role">
          <option value="viewer">Viewer</option>
          <option value="editor">Editor</option>
          <option value="admin">Admin</option>
        </select>

        <button id="login-btn">üîê Login / Get Token</button>
        <p id="current-user" style="margin-top: 0.75rem; font-size: 0.9rem; color: #374151;"></p>
      </article>

      <article class="card" id="search-card">
        <h2>Search Markdown</h2>
        <label for="search-input">Keywords (comma separated)</label>
        <input id="search-input" type="text" placeholder="e.g. websocket, realtime" />
        <button id="search-btn" style="margin-top: 0.75rem;">üîé Search</button>
      </article>

      <article class="card" id="upload-card">
        <h2>Upload Markdown</h2>
        <p style="margin-top: 0; font-size: 0.9rem; color: #6b7280;">Editors and admins can upload .md files.</p>
        <input id="file-input" type="file" accept=".md" class="hidden-input" />
        <button id="upload-btn">‚¨ÜÔ∏è Upload Markdown File</button>
      </article>

      <article class="card" id="admin-card">
        <h2>Admin Tools</h2>
        <div class="inline-actions">
          <button id="reindex-btn">üîÅ Force Reindex</button>
          <button id="history-btn">üìú View Upload History</button>
        </div>
        <div id="history-container"></div>
      </article>
    </section>

    <section>
      <h2 style="margin-bottom: 1rem;">Results</h2>
      <div id="results" class="results"></div>
    </section>

    <footer>
      Built for the University Coding Challenge 2025 ‚Ä¢ Live updates powered by Socket.IO
    </footer>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js" integrity="sha384-AbQ7+wzCTsRmR271GGBqBPdZiZsaAJ+lZeXqIuAv89xDSHLVYDBlnJrped1IovnE" crossorigin="anonymous"></script>
    <script>
      const statusEl = document.getElementById('status');
      const loginBtn = document.getElementById('login-btn');
      const searchBtn = document.getElementById('search-btn');
      const uploadBtn = document.getElementById('upload-btn');
      const reindexBtn = document.getElementById('reindex-btn');
      const historyBtn = document.getElementById('history-btn');
      const fileInput = document.getElementById('file-input');
      const searchInput = document.getElementById('search-input');
      const resultsEl = document.getElementById('results');
      const currentUserEl = document.getElementById('current-user');
      const historyContainer = document.getElementById('history-container');

      const allowedRoles = ['viewer', 'editor', 'admin'];
      let authToken = null;
      let userProfile = null;
      let lastKeywords = '';
      let socket = null;

      const origin = window.location.origin.startsWith('http')
        ? window.location.origin
        : 'http://localhost:3000';

      function setStatus(message, type = 'info', duration = 3000) {
        statusEl.textContent = message;
        statusEl.style.display = 'block';
        statusEl.style.background = type === 'error' ? '#fee2e2' : '#eef2ff';
        statusEl.style.color = type === 'error' ? '#991b1b' : '#1e3a8a';
        if (duration) {
          setTimeout(() => {
            statusEl.style.display = 'none';
          }, duration);
        }
      }

      function requireToken() {
        if (!authToken) {
          setStatus('Please log in to continue.', 'error');
          throw new Error('Missing token');
        }
        return authToken;
      }

      function updateRoleControls() {
        const role = userProfile?.role;
        const isEditorOrAdmin = role === 'editor' || role === 'admin';
        const isAdmin = role === 'admin';

        uploadBtn.disabled = !isEditorOrAdmin;
        reindexBtn.disabled = !isAdmin;
        historyBtn.disabled = !isAdmin;
      }

      function highlightKeywords(text, keywords) {
        let highlighted = text;
        keywords.forEach((keyword) => {
          if (!keyword) return;
          const regex = new RegExp(`(${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
          highlighted = highlighted.replace(regex, '<mark>$1</mark>');
        });
        return highlighted;
      }

      function renderResults(items, keywords) {
        resultsEl.innerHTML = '';
        if (!items.length) {
          resultsEl.innerHTML = '<p style="color:#6b7280;">No matches yet. Try another search.</p>';
          return;
        }

        const fragment = document.createDocumentFragment();

        items.forEach((item) => {
          const card = document.createElement('article');
          card.className = 'result-card';

          const title = document.createElement('h3');
          title.textContent = item.filename;
          card.appendChild(title);

          item.matches
            .sort((a, b) => a.lineNumber - b.lineNumber)
            .forEach((match) => {
              const line = document.createElement('p');
              line.className = 'match-line';
              line.innerHTML = `Ln ${match.lineNumber}: ${highlightKeywords(match.line, keywords)}`;
              card.appendChild(line);
            });

          const actions = document.createElement('div');
          actions.className = 'inline-actions';

          const downloadBtn = document.createElement('button');
          downloadBtn.textContent = '‚¨áÔ∏è Download';
          downloadBtn.addEventListener('click', () => downloadFile(item.filename));
          actions.appendChild(downloadBtn);

          if (userProfile?.role === 'admin') {
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'üóëÔ∏è Delete';
            deleteBtn.addEventListener('click', () => deleteFile(item.filename));
            actions.appendChild(deleteBtn);
          }

          card.appendChild(actions);
          fragment.appendChild(card);
        });

        resultsEl.appendChild(fragment);
      }

      function connectSocket() {
        if (socket) {
          socket.disconnect();
        }
        socket = io(origin, {
          auth: {
            token: authToken,
          },
        });

        socket.on('connect', () => {
          setStatus('Connected to live updates.', 'info', 1500);
        });

        socket.on('disconnect', () => {
          setStatus('Disconnected from live updates.', 'error');
        });

        socket.on('connect_error', (error) => {
          const message = error?.message || 'Live update authentication failed.';
          setStatus(message, 'error');
        });

        socket.on('file_changed', (payload) => {
          const { event, filename, user } = payload;
          const byline = user?.user ? ` by ${user.user}` : '';
          const message = `File ${filename} ${event}${byline}. Refreshing results...`;
          setStatus(message, 'info');
          if (lastKeywords) {
            performSearch(lastKeywords);
          }
        });

        socket.on('index_updated', () => {
          if (lastKeywords) {
            performSearch(lastKeywords);
          }
        });

        socket.on('index_ready', () => {
          if (lastKeywords) {
            performSearch(lastKeywords);
          }
        });
      }

      async function performSearch(rawKeywords) {
        try {
          const token = requireToken();
          const keywords = rawKeywords
            .split(',')
            .map((kw) => kw.trim())
            .filter(Boolean);

          if (!keywords.length) {
            setStatus('Enter at least one keyword to search.', 'error');
            return;
          }

          const params = new URLSearchParams({ keywords: keywords.join(',') });
          const response = await fetch(`${origin}/search-doc?${params.toString()}`, {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({ message: 'Search failed.' }));
            throw new Error(error.message || 'Search failed.');
          }

          const data = await response.json();
          renderResults(data.results || [], keywords);
          lastKeywords = keywords.join(',');
        } catch (error) {
          renderResults([], []);
          console.error(error);
          setStatus(error.message, 'error');
        }
      }

      async function downloadFile(filename) {
        try {
          const token = requireToken();
          const response = await fetch(`${origin}/download-doc/${encodeURIComponent(filename)}`, {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({ message: 'Download failed.' }));
            throw new Error(error.message || 'Download failed.');
          }

          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          link.remove();
          window.URL.revokeObjectURL(url);
        } catch (error) {
          console.error(error);
          setStatus(error.message, 'error');
        }
      }

      async function deleteFile(filename) {
        if (!confirm(`Delete ${filename}? This cannot be undone.`)) {
          return;
        }
        try {
          const token = requireToken();
          const response = await fetch(`${origin}/delete-doc/${encodeURIComponent(filename)}`, {
            method: 'DELETE',
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({ message: 'Delete failed.' }));
            throw new Error(error.message || 'Delete failed.');
          }

          setStatus(`${filename} deleted successfully.`);
          if (lastKeywords) {
            performSearch(lastKeywords);
          }
        } catch (error) {
          console.error(error);
          setStatus(error.message, 'error');
        }
      }

      async function uploadFile(file) {
        try {
          const token = requireToken();
          const formData = new FormData();
          formData.append('file', file);

          const response = await fetch(`${origin}/upload-doc`, {
            method: 'POST',
            headers: {
              Authorization: `Bearer ${token}`,
            },
            body: formData,
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({ message: 'Upload failed.' }));
            throw new Error(error.message || 'Upload failed.');
          }

          setStatus(`${file.name} uploaded successfully.`);
          if (lastKeywords) {
            performSearch(lastKeywords);
          }
        } catch (error) {
          console.error(error);
          setStatus(error.message, 'error');
        }
      }

      async function forceReindex() {
        try {
          const token = requireToken();
          const response = await fetch(`${origin}/force-reindex`, {
            method: 'POST',
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({ message: 'Reindex failed.' }));
            throw new Error(error.message || 'Reindex failed.');
          }

          setStatus('Index rebuilt.');
          if (lastKeywords) {
            performSearch(lastKeywords);
          }
        } catch (error) {
          console.error(error);
          setStatus(error.message, 'error');
        }
      }

      function renderHistoryTable(records) {
        if (!records.length) {
          historyContainer.innerHTML = '<p style="color:#6b7280; margin-top:0.75rem;">No uploads yet.</p>';
          return;
        }

        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        const headers = [
          { key: 'filename', label: 'File' },
          { key: 'user', label: 'User' },
          { key: 'role', label: 'Role' },
          { key: 'uploadedAt', label: 'Uploaded At' },
        ];

        headers.forEach((header) => {
          const th = document.createElement('th');
          th.textContent = header.label;
          th.addEventListener('click', () => {
            const sorted = [...records].sort((a, b) => {
              if (header.key === 'uploadedAt') {
                return new Date(b[header.key]) - new Date(a[header.key]);
              }
              return String(a[header.key]).localeCompare(String(b[header.key]));
            });
            renderHistoryTable(sorted);
          });
          headerRow.appendChild(th);
        });

        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        records.forEach((record) => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${record.filename}</td>
            <td>${record.user}</td>
            <td>${record.role}</td>
            <td>${new Date(record.uploadedAt).toLocaleString()}</td>
          `;
          tbody.appendChild(row);
        });
        table.appendChild(tbody);

        historyContainer.innerHTML = '';
        historyContainer.appendChild(table);
      }

      async function loadHistory() {
        try {
          const token = requireToken();
          const response = await fetch(`${origin}/upload-history`, {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({ message: 'History failed.' }));
            throw new Error(error.message || 'Could not load history.');
          }

          const data = await response.json();
          renderHistoryTable(data.history || []);
        } catch (error) {
          console.error(error);
          setStatus(error.message, 'error');
        }
      }

      loginBtn.addEventListener('click', async () => {
        try {
          const username = document.getElementById('username').value.trim();
          const role = document.getElementById('role').value;

          if (!username) {
            setStatus('Enter a username.', 'error');
            return;
          }

          if (!allowedRoles.includes(role)) {
            setStatus('Select a valid role.', 'error');
            return;
          }

          const params = new URLSearchParams({ user: username, role });
          const response = await fetch(`${origin}/get-token?${params.toString()}`);
          if (!response.ok) {
            const error = await response.json().catch(() => ({ message: 'Login failed.' }));
            throw new Error(error.message || 'Login failed.');
          }

          const data = await response.json();
          authToken = data.token;
          userProfile = { user: username, role };
          currentUserEl.textContent = `Logged in as ${username} (${role})`;
          setStatus('Login successful. Token stored.');
          updateRoleControls();
          connectSocket();
        } catch (error) {
          console.error(error);
          setStatus(error.message, 'error');
        }
      });

      searchBtn.addEventListener('click', () => {
        const value = searchInput.value.trim();
        performSearch(value);
      });

      searchInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          performSearch(searchInput.value.trim());
        }
      });

      uploadBtn.addEventListener('click', () => {
        if (uploadBtn.disabled) {
          setStatus('You do not have permission to upload files.', 'error');
          return;
        }
        fileInput.click();
      });

      fileInput.addEventListener('change', () => {
        const file = fileInput.files[0];
        if (file) {
          if (!file.name.endsWith('.md')) {
            setStatus('Only Markdown files are supported.', 'error');
            return;
          }
          uploadFile(file);
          fileInput.value = '';
        }
      });

      reindexBtn.addEventListener('click', () => {
        if (reindexBtn.disabled) {
          setStatus('Admin role required for reindexing.', 'error');
          return;
        }
        forceReindex();
      });

      historyBtn.addEventListener('click', () => {
        if (historyBtn.disabled) {
          setStatus('Admin role required to view history.', 'error');
          return;
        }
        loadHistory();
      });

      updateRoleControls();
    </script>
  </body>
</html>
