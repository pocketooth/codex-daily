<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Live Markdown Search</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <header class="app-header">
      <h1>Live Markdown Search</h1>
      <div class="session-controls">
        <p id="current-user">Not signed in</p>
        <button id="logout-btn" class="secondary-button" type="button" disabled>Log Out</button>
        <button id="theme-toggle" class="secondary-button" type="button">Toggle Theme</button>
      </div>
    </header>

    <div id="status" class="status"></div>
    <div id="auth-overlay" class="auth-overlay" role="dialog" aria-modal="true" aria-live="polite">
      <article class="card auth-dialog">
        <h2>Sign In</h2>
        <label for="username">Username</label>
        <input id="username" type="text" placeholder="admin, manager, or guest" autocomplete="username" />
        <label for="password" class="mt-075">Password</label>
        <input id="password" type="password" placeholder="Enter your password" autocomplete="current-password" />
        <button id="login-btn" class="mt-075">Sign In</button>
        <p class="mt-075 text-sm muted-text">
          Default passwords follow <code>username_123!</code>.
        </p>
      </article>
    </div>

    <section class="app-grid">

      <article class="card" id="search-card">
        <h2>Search Markdown</h2>
        <label for="search-input">Search keywords or pattern</label>
        <input
          id="search-input"
          type="text"
          placeholder="e.g. websocket, realtime or error|warning"
        />
        <label for="search-mode" class="mt-075">Mode</label>
        <select id="search-mode">
          <option value="and">All keywords (AND)</option>
          <option value="regex">Regex pattern (use | for OR)</option>
          <option value="wildcard">Wildcard (* and ?)</option>
        </select>
        <p class="mt-075 mb-0 text-sm muted-text">
          Use commas to separate keywords for AND search. Regex mode accepts any JavaScript regular
          expression. Wildcard mode supports <code>*</code> for any sequence and <code>?</code> for a
          single character, plus <code>|</code> for alternatives.
        </p>
        <button id="search-btn" class="mt-075">üîé Search</button>
      </article>

      <article class="card" id="upload-card">
        <h2>Upload Markdown</h2>
<p class="mt-0 text-md muted-text">Editors and admins can upload .md files.</p>
        <label for="file-input" class="sr-only">Select a Markdown file to upload</label>
        <input id="file-input" type="file" accept=".md" class="hidden-input" />
        <button id="upload-btn">‚¨ÜÔ∏è Upload Markdown File</button>
      </article>

      <article class="card" id="admin-card">
        <h2>Admin Tools</h2>
        <div class="inline-actions">
          <button id="reindex-btn">üîÅ Force Reindex</button>
          <button id="history-btn">üìú View Upload History</button>
        </div>
        <label class="history-filter-label" for="history-filter">Filter history</label>
        <input id="history-filter" type="text" placeholder="Search by file, user, or role" disabled />
        <div id="history-container"></div>
      </article>
    </section>

    <section>
      <h2 class="mb-1">Results</h2>
      <div id="results" class="results"></div>
    </section>

    <section id="preview-section" class="preview-card is-hidden" data-mode="split">
      <div class="preview-header">
        <div>
          <h2 class="m-0">File Preview</h2>
          <p id="preview-meta" class="mt-035 mb-0 muted-text text-md"></p>
        </div>
        <div class="preview-header-actions">
          <div class="preview-mode-toggle" role="group" aria-label="Preview display mode">
            <button type="button" class="preview-mode-button" data-preview-mode="raw">Raw</button>
            <button type="button" class="preview-mode-button" data-preview-mode="rendered">Markdown</button>
            <button type="button" class="preview-mode-button" data-preview-mode="split">Split</button>
          </div>
          <button id="edit-preview-btn" class="secondary-button is-hidden" type="button">Edit File</button>
          <button id="close-preview" class="secondary-button" type="button">‚úñ Close</button>
        </div>
      </div>
      <h3 id="preview-filename" class="mt-0 mb-075"></h3>
      <div id="preview-body" class="preview-body">
        <pre id="preview-content-raw" class="preview-pane preview-raw"></pre>
        <article id="preview-content-rendered" class="preview-pane preview-rendered"></article>
        <button
          id="preview-sync-toggle"
          class="preview-sync-toggle"
          type="button"
          aria-pressed="true"
          title="Toggle synchronized scrolling"
        >
          <span class="sync-dots">
            <span class="sync-dot"></span>
            <span class="sync-dot"></span>
            <span class="sync-dot"></span>
          </span>
          <span class="sync-label">Sync</span>
        </button>
      </div>
      <div id="preview-editor" class="preview-editor" aria-hidden="true">
        <textarea id="preview-editor-input" spellcheck="false"></textarea>
        <div class="preview-editor-actions">
          <button id="preview-save-btn" type="button">Save Changes</button>
          <button id="preview-cancel-btn" type="button" class="secondary-button">Cancel</button>
        </div>
        <p class="preview-editor-hint">Saving overwrites the existing Markdown file and rebuilds the search index.</p>
      </div>
    </section>

    <footer>
      Built for the University Coding Challenge 2025 ‚Ä¢ Live updates powered by Socket.IO
    </footer>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
      const statusEl = document.getElementById('status');
      const loginBtn = document.getElementById('login-btn');
      const logoutBtn = document.getElementById('logout-btn');
      const usernameInput = document.getElementById('username');
      const passwordInput = document.getElementById('password');
      const authOverlay = document.getElementById('auth-overlay');
      const searchBtn = document.getElementById('search-btn');
      const uploadBtn = document.getElementById('upload-btn');
      const reindexBtn = document.getElementById('reindex-btn');
      const historyBtn = document.getElementById('history-btn');
      const fileInput = document.getElementById('file-input');
      const searchInput = document.getElementById('search-input');
      const searchModeSelect = document.getElementById('search-mode');
      const resultsEl = document.getElementById('results');
      const currentUserEl = document.getElementById('current-user');
      const historyContainer = document.getElementById('history-container');
      const historyFilterInput = document.getElementById('history-filter');
      const themeToggleBtn = document.getElementById('theme-toggle');
      const previewSection = document.getElementById('preview-section');
      const previewFilenameEl = document.getElementById('preview-filename');
      const previewMetaEl = document.getElementById('preview-meta');
      const previewRawEl = document.getElementById('preview-content-raw');
      const previewRenderedEl = document.getElementById('preview-content-rendered');
      const previewSyncToggleBtn = document.getElementById('preview-sync-toggle');
      const previewModeButtons = Array.from(document.querySelectorAll('[data-preview-mode]'));
      const previewEditBtn = document.getElementById('edit-preview-btn');
      const previewEditor = document.getElementById('preview-editor');
      const previewEditorInput = document.getElementById('preview-editor-input');
      const previewSaveBtn = document.getElementById('preview-save-btn');
      const previewCancelBtn = document.getElementById('preview-cancel-btn');
      const closePreviewBtn = document.getElementById('close-preview');

      const previewModes = ['raw', 'rendered', 'split'];
      const previewModeStorageKey = 'md-preview-mode';
      const previewSyncStorageKey = 'md-preview-sync';
      const tokenStorageKey = 'md-search-token';
      const userStorageKey = 'md-search-user';
      const storedPreviewMode = localStorage.getItem(previewModeStorageKey);
      const storedSyncPref = localStorage.getItem(previewSyncStorageKey);
      let currentPreviewMode = previewModes.includes(storedPreviewMode) ? storedPreviewMode : 'split';
      let syncPreviewScroll = storedSyncPref ? storedSyncPref === 'true' : true;
      let syncingScroll = false;
      let authToken = null;
      let userProfile = null;
      let lastSearch = null;
      let activeDescriptor = null;
      let currentPreviewFilename = null;
      let currentPreviewContent = '';
      let isEditingPreview = false;
      let socket = null;
      let statusTimeoutId = null;
      let historyRecords = [];
      let historySort = { key: 'uploadedAt', direction: 'desc' };
      let historyLoaded = false;

      const origin = window.location.origin.startsWith('http')
        ? window.location.origin
        : 'http://localhost:3000';

      function setAuthenticatedState(isAuthenticated) {
        if (authOverlay) {
          authOverlay.classList.toggle('hidden', isAuthenticated);
        }
        document.body.classList.toggle('auth-locked', !isAuthenticated);
        if (logoutBtn) {
          logoutBtn.disabled = !isAuthenticated;
        }
        updatePreviewEditControls();
      }

      function persistSession(token, profile) {
        localStorage.setItem(tokenStorageKey, token);
        localStorage.setItem(userStorageKey, JSON.stringify(profile));
      }

      function clearSession({ silent } = {}) {
        authToken = null;
        userProfile = null;
        lastSearch = null;
        localStorage.removeItem(tokenStorageKey);
        localStorage.removeItem(userStorageKey);
        if (socket) {
          socket.disconnect();
          socket = null;
        }
        currentUserEl.textContent = 'Not signed in';
        historyRecords = [];
        historyLoaded = false;
        historyContainer.innerHTML = '';
        historyFilterInput.value = '';
        renderResults([], null);
        currentPreviewFilename = null;
        currentPreviewContent = '';
        exitPreviewEditMode({ silent: true });
        hidePreview();
        updateRoleControls();
        setAuthenticatedState(false);
        if (!silent) {
          setStatus('Please sign in to continue.', 'info');
        }
      }

      function handleAuthFailure(response) {
        if (response && response.status === 401) {
          clearSession({ silent: true });
          throw new Error('Session expired. Please sign in again.');
        }
      }

      async function initializeAuth() {
        const storedToken = localStorage.getItem(tokenStorageKey);
        if (!storedToken) {
          setAuthenticatedState(false);
          return;
        }
        authToken = storedToken;
        try {
          const response = await fetch(`${origin}/session`, {
            headers: {
              Authorization: `Bearer ${storedToken}`,
            },
          });
          if (!response.ok) {
            throw new Error('Session expired.');
          }
          const data = await response.json();
          userProfile = data.user;
          persistSession(storedToken, userProfile);
          currentUserEl.textContent = `Logged in as ${userProfile.user} (${userProfile.role})`;
          setAuthenticatedState(true);
          updateRoleControls();
          connectSocket();
          rerunLastSearch();
        } catch (error) {
          console.error(error);
          clearSession({ silent: true });
        }
      }

      if (window.marked && typeof window.marked.setOptions === 'function') {
        window.marked.setOptions({ breaks: true, gfm: true });
      }

      function readCssVar(name) {
        const bodyStyle = getComputedStyle(document.body);
        const rootStyle = getComputedStyle(document.documentElement);
        const value = bodyStyle.getPropertyValue(name) || rootStyle.getPropertyValue(name);
        return value.trim();
      }

      function escapeHtml(value) {
        return value
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function renderMarkdown(content) {
        const safeContent = typeof content === 'string' ? content : '';
        if (window.marked && typeof window.marked.parse === 'function') {
          return window.marked.parse(safeContent);
        }
        return `<div>${escapeHtml(safeContent).replace(/\n/g, '<br />')}</div>`;
      }

      function updatePreviewModeButtons() {
        previewModeButtons.forEach((button) => {
          const mode = button.getAttribute('data-preview-mode');
          const isActive = mode === currentPreviewMode;
          button.classList.toggle('active', isActive);
          button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
      }

      function setPreviewMode(mode, options = {}) {
        const fallbackMode = previewModes.includes(mode) ? mode : 'split';
        currentPreviewMode = fallbackMode;
        if (previewSection) {
          previewSection.dataset.mode = currentPreviewMode;
        }
        if (options.persist !== false) {
          localStorage.setItem(previewModeStorageKey, currentPreviewMode);
        }
        updatePreviewModeButtons();
        updateSyncToggle();
      }

      function renderPreviewContent(content) {
        if (!previewRawEl || !previewRenderedEl) return;
        const value = typeof content === 'string' ? content : '';
        currentPreviewContent = value;
        if (value) {
          const escaped = escapeHtml(value);
          previewRawEl.innerHTML = activeDescriptor ? highlightMatches(escaped, activeDescriptor) : escaped;
          previewRenderedEl.innerHTML = renderMarkdown(value);
          if (activeDescriptor) {
            highlightHtmlContainer(previewRenderedEl, activeDescriptor);
          }
        } else {
          previewRawEl.innerHTML = '<span class="muted-text">(empty file)</span>';
          previewRenderedEl.innerHTML = '<p class="muted-text">(empty file)</p>';
        }
        previewRawEl.scrollTop = 0;
        previewRenderedEl.scrollTop = 0;
      }

      function updateSyncToggle() {
        if (!previewSyncToggleBtn) {
          return;
        }
        const isSplit = currentPreviewMode === 'split';
        previewSyncToggleBtn.disabled = !isSplit;
        previewSyncToggleBtn.classList.toggle('active', syncPreviewScroll && isSplit);
        previewSyncToggleBtn.setAttribute('aria-pressed', syncPreviewScroll && isSplit ? 'true' : 'false');
        previewSyncToggleBtn.setAttribute(
          'title',
          syncPreviewScroll && isSplit ? 'Click to disable synchronized scrolling' : 'Click to enable synchronized scrolling'
        );
      }

      setPreviewMode(currentPreviewMode, { persist: false });

      previewModeButtons.forEach((button) => {
        button.addEventListener('click', () => {
          const mode = button.getAttribute('data-preview-mode');
          setPreviewMode(mode);
        });
      });

      if (previewRawEl) {
        previewRawEl.addEventListener('scroll', () => syncScrollPositions(previewRawEl, previewRenderedEl));
      }

      if (previewRenderedEl) {
        previewRenderedEl.addEventListener('scroll', () => syncScrollPositions(previewRenderedEl, previewRawEl));
      }

      if (previewSyncToggleBtn) {
        previewSyncToggleBtn.addEventListener('click', () => {
          if (currentPreviewMode !== 'split') {
            setStatus('Switch to split view to sync scrolling.', 'info');
            return;
          }
          syncPreviewScroll = !syncPreviewScroll;
          localStorage.setItem(previewSyncStorageKey, String(syncPreviewScroll));
          updateSyncToggle();
        });
      }

      function setStatus(message, type = 'info', duration = 3000) {
        statusEl.textContent = message;
        statusEl.style.display = 'block';
        const infoBg = readCssVar('--status-info-bg') || '#eef2ff';
        const infoText = readCssVar('--status-info-text') || '#1e3a8a';
        const errorBg = readCssVar('--status-error-bg') || '#fee2e2';
        const errorText = readCssVar('--status-error-text') || '#991b1b';

        if (type === 'error') {
          statusEl.style.background = errorBg;
          statusEl.style.color = errorText;
        } else {
          statusEl.style.background = infoBg;
          statusEl.style.color = infoText;
        }

        if (statusTimeoutId) {
          clearTimeout(statusTimeoutId);
        }

        if (duration) {
          statusTimeoutId = setTimeout(() => {
            statusEl.style.display = 'none';
          }, duration);
        }
      }

      function applyTheme(theme) {
        const normalized = theme === 'dark' ? 'dark' : 'light';
        document.body.classList.toggle('dark', normalized === 'dark');
        localStorage.setItem('md-search-theme', normalized);
        if (themeToggleBtn) {
          themeToggleBtn.textContent = normalized === 'dark' ? 'Switch to Light Mode' : 'Switch to Dark Mode';
        }
      }

      function toggleTheme() {
        const nextTheme = document.body.classList.contains('dark') ? 'light' : 'dark';
        applyTheme(nextTheme);
      }

      const storedTheme = localStorage.getItem('md-search-theme');
      if (storedTheme) {
        applyTheme(storedTheme);
      } else {
        const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        applyTheme(prefersDark ? 'dark' : 'light');
      }

      themeToggleBtn.addEventListener('click', toggleTheme);

      function requireToken() {
        if (!authToken) {
          setAuthenticatedState(false);
          setStatus('Please log in to continue.', 'error');
          throw new Error('Missing token');
        }
        return authToken;
      }

      function updateRoleControls() {
        const isAuthenticated = Boolean(userProfile);
        const role = userProfile?.role;
        const isEditorOrAdmin = role === 'editor' || role === 'admin';
        const isAdmin = role === 'admin';

        if (currentUserEl) {
          currentUserEl.textContent = isAuthenticated
            ? `Logged in as ${userProfile.user} (${role})`
            : 'Not signed in';
        }

        uploadBtn.disabled = !isAuthenticated || !isEditorOrAdmin;
        reindexBtn.disabled = !isAuthenticated || !isAdmin;
        historyBtn.disabled = !isAuthenticated || !isAdmin;
        historyFilterInput.disabled = !isAuthenticated || !isAdmin;
        if (logoutBtn) {
          logoutBtn.disabled = !isAuthenticated;
        }

        if (!isAdmin) {
          historyFilterInput.value = '';
          historyRecords = [];
          historyLoaded = false;
          historyContainer.innerHTML = '';
        } else if (!historyLoaded && historyContainer.innerHTML.trim() === '') {
          renderHistoryTable();
        }
        updatePreviewEditControls();
      }

      function wildcardPatternToRegexSource(pattern) {
        const placeholder = pattern
          .replace(/\\\*/g, '___ESCAPED_STAR___')
          .replace(/\\\?/g, '___ESCAPED_Q___')
          .replace(/\*/g, '___WILDCARD_STAR___')
          .replace(/\?/g, '___WILDCARD_Q___');

        const escaped = placeholder.replace(/([.+^${}()\[\]\\])/g, '\\$1');

        return escaped
          .replace(/___WILDCARD_STAR___/g, '.*')
          .replace(/___WILDCARD_Q___/g, '.')
          .replace(/___ESCAPED_STAR___/g, '\\*')
          .replace(/___ESCAPED_Q___/g, '\\?');
      }

      function highlightMatches(text, descriptor) {
        if (!descriptor) {
          return text;
        }

        if (descriptor.mode === 'and') {
          let highlighted = text;
          (descriptor.keywords || []).forEach((keyword) => {
            if (!keyword) return;
            const regex = new RegExp(`(${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            highlighted = highlighted.replace(regex, '<mark>$1</mark>');
          });
          return highlighted;
        }

        if (descriptor.mode === 'regex' || descriptor.mode === 'wildcard') {
          try {
            const flags = descriptor.flags?.includes('g') ? descriptor.flags : `${descriptor.flags || ''}g`;
            const regex = new RegExp(descriptor.pattern, flags.includes('i') ? flags : `${flags}i`);
            return text.replace(regex, (match) => `<mark>${match}</mark>`);
          } catch (_error) {
            return text;
          }
        }

        return text;
      }

      function highlightHtmlContainer(container, descriptor) {
        if (!descriptor || !container) {
          return;
        }
        const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);
        const textNodes = [];
        let current;
        while ((current = walker.nextNode())) {
          if (current.parentElement && current.parentElement.tagName === 'SCRIPT') {
            continue;
          }
          textNodes.push(current);
        }
        textNodes.forEach((node) => {
          const original = node.textContent;
          if (!original?.trim()) {
            return;
          }
          const escaped = escapeHtml(original);
          const highlighted = highlightMatches(escaped, descriptor);
          if (highlighted === escaped) {
            return;
          }
          const temp = document.createElement('span');
          temp.innerHTML = highlighted;
          const fragment = document.createDocumentFragment();
          while (temp.firstChild) {
            fragment.appendChild(temp.firstChild);
          }
          if (node.parentNode) {
            node.parentNode.replaceChild(fragment, node);
          }
        });
      }

      function canEditPreview() {
        const role = userProfile?.role;
        return role === 'editor' || role === 'admin';
      }

      function updatePreviewEditControls() {
        if (!previewEditBtn) {
          return;
        }
        const canEdit = canEditPreview();
        previewEditBtn.classList.toggle('is-hidden', !canEdit);
        const hasFile = Boolean(currentPreviewFilename);
        previewEditBtn.disabled = !canEdit || !hasFile || isEditingPreview;
        if (!canEdit && isEditingPreview) {
          exitPreviewEditMode({ refresh: false });
        }
      }

      function enterPreviewEditMode() {
        if (!canEditPreview()) {
          setStatus('Editor or admin role required to edit files.', 'error');
          return;
        }
        if (!currentPreviewFilename) {
          setStatus('Open a file to edit.', 'error');
          return;
        }
        isEditingPreview = true;
        previewSection?.classList.add('editing');
        if (previewEditor) {
          previewEditor.setAttribute('aria-hidden', 'false');
        }
        if (previewEditorInput) {
          previewEditorInput.value = currentPreviewContent || '';
          previewEditorInput.focus();
        }
        updatePreviewEditControls();
      }

      function exitPreviewEditMode(options = {}) {
        if (!previewSection) {
          return;
        }
        isEditingPreview = false;
        previewSection.classList.remove('editing');
        if (previewEditor) {
          previewEditor.setAttribute('aria-hidden', 'true');
        }
        if (previewEditorInput && !options.keepDraft) {
          previewEditorInput.value = '';
        }
        if (options.refresh !== false && currentPreviewContent) {
          renderPreviewContent(currentPreviewContent);
        }
        updatePreviewEditControls();
      }

      async function savePreviewEdits() {
        try {
          if (!canEditPreview()) {
            setStatus('Editor or admin role required to edit files.', 'error');
            return;
          }
          if (!currentPreviewFilename) {
            setStatus('No file selected for editing.', 'error');
            return;
          }
          const token = requireToken();
          const nextContent = previewEditorInput?.value ?? '';
          const originalLabel = previewSaveBtn?.textContent;
          if (previewSaveBtn) {
            previewSaveBtn.disabled = true;
            previewSaveBtn.textContent = 'Saving...';
          }
          const response = await fetch(`${origin}/edit-doc/${encodeURIComponent(currentPreviewFilename)}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              Authorization: `Bearer ${token}`,
            },
            body: JSON.stringify({ content: nextContent }),
          });
          if (!response.ok) {
            handleAuthFailure(response);
            const error = await response.json().catch(() => ({ message: 'Save failed.' }));
            throw new Error(error.message || 'Save failed.');
          }
          currentPreviewContent = nextContent;
          setStatus('File saved successfully.');
          exitPreviewEditMode({ refresh: true });
          previewFile(currentPreviewFilename);
          rerunLastSearch();
        } catch (error) {
          console.error(error);
          setStatus(error.message, 'error');
        } finally {
          if (previewSaveBtn) {
            previewSaveBtn.disabled = false;
            previewSaveBtn.textContent = originalLabel || 'Save Changes';
          }
        }
      }

      function syncScrollPositions(source, target) {
        if (!syncPreviewScroll || syncingScroll || currentPreviewMode !== 'split') {
          return;
        }
        if (!source || !target) {
          return;
        }
        const sourceMax = source.scrollHeight - source.clientHeight;
        if (sourceMax <= 0) {
          return;
        }
        const targetMax = target.scrollHeight - target.clientHeight;
        syncingScroll = true;
        const ratio = source.scrollTop / sourceMax;
        target.scrollTop = ratio * targetMax;
        requestAnimationFrame(() => {
          syncingScroll = false;
        });
      }

      function renderResults(items, descriptor) {
        activeDescriptor = descriptor || null;
        resultsEl.innerHTML = '';
        if (!items.length) {
          resultsEl.innerHTML = '<p class="muted-text">No matches yet. Try another search.</p>';
          return;
        }

        const fragment = document.createDocumentFragment();

        items.forEach((item) => {
          const card = document.createElement('article');
          card.className = 'result-card';

          const title = document.createElement('h3');
          title.textContent = item.filename;
          card.appendChild(title);

          item.matches
            .sort((a, b) => a.lineNumber - b.lineNumber)
            .forEach((match) => {
              const line = document.createElement('p');
              line.className = 'match-line';
              line.innerHTML = `Ln ${match.lineNumber}: ${highlightMatches(match.line, descriptor)}`;
              card.appendChild(line);
            });

          const actions = document.createElement('div');
          actions.className = 'inline-actions';

          const previewBtn = document.createElement('button');
          previewBtn.type = 'button';
          previewBtn.textContent = 'üëÄ Preview';
          previewBtn.addEventListener('click', () => previewFile(item.filename));
          actions.appendChild(previewBtn);

          const downloadBtn = document.createElement('button');
          downloadBtn.type = 'button';
          downloadBtn.textContent = '‚¨áÔ∏è Download';
          downloadBtn.addEventListener('click', () => downloadFile(item.filename));
          actions.appendChild(downloadBtn);

          if (userProfile?.role === 'admin') {
            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.textContent = 'üóëÔ∏è Delete';
            deleteBtn.addEventListener('click', () => deleteFile(item.filename));
            actions.appendChild(deleteBtn);
          }

          card.appendChild(actions);
          fragment.appendChild(card);
        });

        resultsEl.appendChild(fragment);
      }

      function formatFileSize(bytes) {
        if (!Number.isFinite(bytes)) {
          return 'unknown size';
        }
        if (bytes < 1024) {
          return `${bytes} B`;
        }
        if (bytes < 1024 * 1024) {
          return `${(bytes / 1024).toFixed(1)} KB`;
        }
        return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
      }

      function hidePreview() {
        exitPreviewEditMode({ refresh: false });
        if (previewSection) {
          previewSection.classList.add('is-hidden');
          previewSection.style.display = '';
        }
        previewFilenameEl.textContent = '';
        previewMetaEl.textContent = '';
        if (previewRawEl) {
          previewRawEl.innerHTML = '';
        }
        if (previewRenderedEl) {
          previewRenderedEl.innerHTML = '';
        }
        currentPreviewFilename = null;
        currentPreviewContent = '';
        updatePreviewEditControls();
      }

      function showPreview(data) {
        exitPreviewEditMode({ refresh: false, keepDraft: true });
        currentPreviewFilename = data.filename;
        previewFilenameEl.textContent = data.filename;
        const lineLabel = data.lineCount === 1 ? '1 line' : `${data.lineCount} lines`;
        previewMetaEl.textContent = `${lineLabel} ÔøΩ?ÔøΩ ${formatFileSize(data.size || 0)}`;
        renderPreviewContent(data.content || '');
        if (previewSection) {
          previewSection.classList.remove('is-hidden');
          previewSection.style.display = 'block';
        }
        setPreviewMode(currentPreviewMode, { persist: false });
        updatePreviewEditControls();
      }

      async function previewFile(filename) {
        try {
          const token = requireToken();
          const response = await fetch(`${origin}/preview-doc/${encodeURIComponent(filename)}`, {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (!response.ok) {
            handleAuthFailure(response);
            const error = await response.json().catch(() => ({ message: 'Preview failed.' }));
            throw new Error(error.message || 'Preview failed.');
          }

          const data = await response.json();
          showPreview(data);
        } catch (error) {
          console.error(error);
          setStatus(error.message, 'error');
        }
      }

      function connectSocket() {
        if (!authToken) {
          return;
        }
        if (socket) {
          socket.disconnect();
        }
        socket = io(origin, {
          auth: {
            token: authToken,
          },
        });

        socket.on('connect', () => {
          setStatus('Connected to live updates.', 'info', 1500);
        });

        socket.on('disconnect', () => {
          setStatus('Disconnected from live updates.', 'error');
        });

        socket.on('connect_error', (error) => {
          const message = error?.message || 'Live update authentication failed.';
          setStatus(message, 'error');
        });

        socket.on('file_changed', (payload) => {
          const { event, filename, user } = payload;
          const byline = user?.user ? ` by ${user.user}` : '';
          const message = `File ${filename} ${event}${byline}. Refreshing results...`;
          setStatus(message, 'info');
          if (previewSection.style.display !== 'none' && previewFilenameEl.textContent === filename) {
            if (event === 'deleted' || event === 'removed') {
              hidePreview();
            } else {
              previewFile(filename);
            }
          }
          rerunLastSearch();
        });

        socket.on('index_updated', () => {
          rerunLastSearch();
        });

        socket.on('index_ready', () => {
          rerunLastSearch();
        });
      }

      function rerunLastSearch() {
        if (lastSearch) {
          performSearch(lastSearch.input, lastSearch.mode, { skipUiSync: true });
        }
      }

      async function performSearch(rawInput, mode, options = {}) {
        try {
          const token = requireToken();
          const selectedMode = mode || 'and';
          const trimmed = (rawInput || '').trim();

          if (!trimmed) {
            setStatus('Enter at least one keyword or pattern to search.', 'error');
            return;
          }

          const params = new URLSearchParams({ keywords: trimmed, mode: selectedMode });
          let requestValue = trimmed;

          if (selectedMode === 'and') {
            const keywords = trimmed
              .split(',')
              .map((kw) => kw.trim())
              .filter(Boolean);

            if (!keywords.length) {
              setStatus('Enter at least one keyword to search.', 'error');
              return;
            }

            requestValue = keywords.join(',');
            params.set('keywords', requestValue);
          } else if (selectedMode === 'regex') {
            try {
              new RegExp(trimmed);
            } catch (_error) {
              setStatus('Invalid regular expression. Please fix the pattern and try again.', 'error');
              return;
            }
          } else if (selectedMode === 'wildcard') {
            try {
              new RegExp(wildcardPatternToRegexSource(trimmed));
            } catch (_error) {
              setStatus('Invalid wildcard pattern. Please fix the expression and try again.', 'error');
              return;
            }
          } else {
            setStatus('Unsupported search mode selected.', 'error');
            return;
          }

          const response = await fetch(`${origin}/search-doc?${params.toString()}`, {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (!response.ok) {
            handleAuthFailure(response);
            const error = await response.json().catch(() => ({ message: 'Search failed.' }));
            throw new Error(error.message || 'Search failed.');
          }

          const data = await response.json();
          let descriptor = null;

          if (data.mode === 'regex' || data.mode === 'wildcard') {
            descriptor = {
              mode: data.mode,
              pattern: data.pattern,
              flags: data.flags,
            };
          } else {
            const keywords = (data.keywords || requestValue.split(',')).map((kw) => kw.trim()).filter(Boolean);
            descriptor = {
              mode: 'and',
              keywords,
            };
          }

          renderResults(data.results || [], descriptor);
          lastSearch = { input: requestValue, mode: selectedMode };

          if (!options.skipUiSync) {
            searchModeSelect.value = selectedMode;
          }
        } catch (error) {
          renderResults([], null);
          console.error(error);
          setStatus(error.message, 'error');
        }
      }

      async function downloadFile(filename) {
        try {
          const token = requireToken();
          const response = await fetch(`${origin}/download-doc/${encodeURIComponent(filename)}`, {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (!response.ok) {
            handleAuthFailure(response);
            const error = await response.json().catch(() => ({ message: 'Download failed.' }));
            throw new Error(error.message || 'Download failed.');
          }

          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          link.remove();
          window.URL.revokeObjectURL(url);
        } catch (error) {
          console.error(error);
          setStatus(error.message, 'error');
        }
      }

      async function deleteFile(filename) {
        if (!confirm(`Delete ${filename}? This cannot be undone.`)) {
          return;
        }
        try {
          const token = requireToken();
          const response = await fetch(`${origin}/delete-doc/${encodeURIComponent(filename)}`, {
            method: 'DELETE',
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (!response.ok) {
            handleAuthFailure(response);
            const error = await response.json().catch(() => ({ message: 'Delete failed.' }));
            throw new Error(error.message || 'Delete failed.');
          }

          setStatus(`${filename} deleted successfully.`);
          if (previewSection.style.display !== 'none' && previewFilenameEl.textContent === filename) {
            hidePreview();
          }
          rerunLastSearch();
        } catch (error) {
          console.error(error);
          setStatus(error.message, 'error');
        }
      }

      async function uploadFile(file) {
        try {
          const token = requireToken();
          const formData = new FormData();
          formData.append('file', file);

          const response = await fetch(`${origin}/upload-doc`, {
            method: 'POST',
            headers: {
              Authorization: `Bearer ${token}`,
            },
            body: formData,
          });

          if (!response.ok) {
            handleAuthFailure(response);
            const error = await response.json().catch(() => ({ message: 'Upload failed.' }));
            throw new Error(error.message || 'Upload failed.');
          }

          setStatus(`${file.name} uploaded successfully.`);
          rerunLastSearch();
        } catch (error) {
          console.error(error);
          setStatus(error.message, 'error');
        }
      }

      async function forceReindex() {
        try {
          const token = requireToken();
          const response = await fetch(`${origin}/force-reindex`, {
            method: 'POST',
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (!response.ok) {
            handleAuthFailure(response);
            const error = await response.json().catch(() => ({ message: 'Reindex failed.' }));
            throw new Error(error.message || 'Reindex failed.');
          }

          setStatus('Index rebuilt.');
          rerunLastSearch();
        } catch (error) {
          console.error(error);
          setStatus(error.message, 'error');
        }
      }

      function getFilteredHistory() {
        const term = historyFilterInput.value.trim().toLowerCase();
        if (!term) {
          return [...historyRecords];
        }
        return historyRecords.filter((record) => {
          return [record.filename, record.user, record.role, new Date(record.uploadedAt).toLocaleString()]
            .map((value) => String(value).toLowerCase())
            .some((value) => value.includes(term));
        });
      }

      function getSortedHistory(records) {
        if (!historySort.key) {
          return [...records];
        }
        const multiplier = historySort.direction === 'asc' ? 1 : -1;
        return [...records].sort((a, b) => {
          if (historySort.key === 'uploadedAt') {
            return (new Date(a.uploadedAt) - new Date(b.uploadedAt)) * multiplier;
          }
          return String(a[historySort.key]).localeCompare(String(b[historySort.key])) * multiplier;
        });
      }

      function renderHistoryTable() {
        if (!historyRecords.length) {
          if (!historyLoaded) {
            historyContainer.innerHTML = '<p class="muted-text mt-075">History not loaded yet. Select ‚ÄúView Upload History‚Äù.</p>';
          } else {
            historyContainer.innerHTML = '<p class="muted-text mt-075">No uploads yet.</p>';
          }
          return;
        }

        const filtered = getFilteredHistory();
        if (!filtered.length) {
          historyContainer.innerHTML = '<p class="muted-text mt-075">No uploads match your filter.</p>';
          return;
        }

        const records = getSortedHistory(filtered);

        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        const headers = [
          { key: 'filename', label: 'File' },
          { key: 'user', label: 'User' },
          { key: 'role', label: 'Role' },
          { key: 'uploadedAt', label: 'Uploaded At' },
        ];

        headers.forEach((header) => {
          const th = document.createElement('th');
          const isActive = historySort.key === header.key;
          const arrow = isActive ? (historySort.direction === 'asc' ? ' ‚ñ≤' : ' ‚ñº') : '';
          th.textContent = `${header.label}${arrow}`;
          th.addEventListener('click', () => {
            if (historySort.key === header.key) {
              historySort.direction = historySort.direction === 'asc' ? 'desc' : 'asc';
            } else {
              historySort = {
                key: header.key,
                direction: header.key === 'uploadedAt' ? 'desc' : 'asc',
              };
            }
            renderHistoryTable();
          });
          headerRow.appendChild(th);
        });

        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        records.forEach((record) => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${record.filename}</td>
            <td>${record.user}</td>
            <td>${record.role}</td>
            <td>${new Date(record.uploadedAt).toLocaleString()}</td>
          `;
          tbody.appendChild(row);
        });
        table.appendChild(tbody);

        historyContainer.innerHTML = '';
        historyContainer.appendChild(table);
      }

      async function loadHistory() {
        try {
          const token = requireToken();
          historyContainer.innerHTML = '<p class="muted-text mt-075">Loading history‚Ä¶</p>';
          const response = await fetch(`${origin}/upload-history`, {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (!response.ok) {
            handleAuthFailure(response);
            const error = await response.json().catch(() => ({ message: 'History failed.' }));
            throw new Error(error.message || 'Could not load history.');
          }

          const data = await response.json();
          historyRecords = data.history || [];
          historySort = { key: 'uploadedAt', direction: 'desc' };
          historyFilterInput.value = '';
          historyFilterInput.disabled = false;
          historyLoaded = true;
          renderHistoryTable();
        } catch (error) {
          console.error(error);
          setStatus(error.message, 'error');
        }
      }

      async function attemptLogin() {
        try {
          const username = (usernameInput?.value || '').trim();
          const password = passwordInput?.value || '';

          if (!username || !password) {
            setStatus('Enter your username and password.', 'error');
            return;
          }

          const response = await fetch(`${origin}/login`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ username, password }),
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({ message: 'Login failed.' }));
            throw new Error(error.message || 'Login failed.');
          }

          const data = await response.json();
          authToken = data.token;
          userProfile = data.user;
          persistSession(authToken, userProfile);
          if (passwordInput) {
            passwordInput.value = '';
          }
          currentUserEl.textContent = `Logged in as ${userProfile.user} (${userProfile.role})`;
          setStatus('Login successful. Token stored.');
          setAuthenticatedState(true);
          updateRoleControls();
          connectSocket();
          rerunLastSearch();
        } catch (error) {
          console.error(error);
          setStatus(error.message, 'error');
        }
      }

      if (loginBtn) {
        loginBtn.addEventListener('click', () => {
          attemptLogin();
        });
      }

      [usernameInput, passwordInput].forEach((input) => {
        if (!input) return;
        input.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            attemptLogin();
          }
        });
      });

      if (logoutBtn) {
        logoutBtn.addEventListener('click', () => {
          clearSession({ silent: true });
          setStatus('Logged out.');
        });
      }

      searchBtn.addEventListener('click', () => {
        performSearch(searchInput.value, searchModeSelect.value);
      });

      searchInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          performSearch(searchInput.value, searchModeSelect.value);
        }
      });

      uploadBtn.addEventListener('click', () => {
        if (uploadBtn.disabled) {
          setStatus('You do not have permission to upload files.', 'error');
          return;
        }
        fileInput.click();
      });

      fileInput.addEventListener('change', () => {
        const file = fileInput.files[0];
        if (file) {
          if (!file.name.endsWith('.md')) {
            setStatus('Only Markdown files are supported.', 'error');
            return;
          }
          uploadFile(file);
          fileInput.value = '';
        }
      });

      reindexBtn.addEventListener('click', () => {
        if (reindexBtn.disabled) {
          setStatus('Admin role required for reindexing.', 'error');
          return;
        }
        forceReindex();
      });

      historyFilterInput.addEventListener('input', () => {
        if (historyFilterInput.disabled) {
          return;
        }
        renderHistoryTable();
      });

      historyBtn.addEventListener('click', () => {
        if (historyBtn.disabled) {
          setStatus('Admin role required to view history.', 'error');
          return;
        }
        loadHistory();
      });

      closePreviewBtn.addEventListener('click', () => {
        hidePreview();
      });

      if (previewEditBtn) {
        previewEditBtn.addEventListener('click', () => {
          if (previewEditBtn.classList.contains('is-hidden')) {
            setStatus('Editor or admin role required to edit files.', 'error');
            return;
          }
          if (isEditingPreview) {
            exitPreviewEditMode();
          } else {
            enterPreviewEditMode();
          }
        });
      }

      if (previewCancelBtn) {
        previewCancelBtn.addEventListener('click', () => {
          exitPreviewEditMode({ refresh: true });
        });
      }

      if (previewSaveBtn) {
        previewSaveBtn.addEventListener('click', () => {
          savePreviewEdits();
        });
      }

      setAuthenticatedState(false);
      initializeAuth();

      updateRoleControls();
    </script>
  </body>
</html>





